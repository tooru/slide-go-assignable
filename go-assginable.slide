Goのインタフェースと代入
横浜Go読書会 #15
7 Apr 2018

Tooru Takahashi

@tooru

https://github.com/tooru/slide-go-assignable


* 話すこと

- 経緯
- 代入可能とは？
- 呼び出しについて
- まとめ

* 経緯

- 「Goなら分かるシステムプログラミング」のp19の[[https://play.golang.org/p/k0pLFTs_3YY][コード]]例に不可解な代入があった(17行目)。
- 一見、型が違いそうだがコンパイルエラーにはならない。12行目が*Greeter型であれば気にならなかったのだが。

.code -numbers src/main.go /^type Talker/,

* なぜ代入できるのか

- ある変数にある値が代入できる、とはどういう決まりがあるのか？	
- 言語仕様を読むのが手っ取り早い。
- ということで
- [[https://golang.org/ref/spec][Goの言語仕様 (The Go Programming Language Specification)]] を読んでみたという発表です。

* 代入可能とは？ (1/3) Assinablity 

.link https://golang.org/ref/spec#Assignability

.code slide/assignability.txt

- 3つ目の「TがInterface型でxがTを実装している」が該当しそう
- Talkerの例では「 `Talker` がInterface型で `&Greeter{"wozozo"}` がTを実装している」といえればよい
- では、xがTを実装しているとは？？

* 代入可能とは？ (2/3) Interface Types

.link https://golang.org/ref/spec#Interface_types

.code slide/interfaceTypes.txt

- インタフェースのメソッドセット(メソッドの集まり)全てを持つ型は、そのインタフェースを *実装している* といえる
- Talkerの例では `&Greeter{"wozozo"}` の型である `Greeter` のポインタ が `Talk()` を持っていれば実装しているということ、、でも、、

.code -numbers src/main.go /^func \(g Greeter\)/

- 実装しているといって良いものか
- それには、メソッドセットを調べる必要がある

* 代入可能とは？ (3/3) Method Sets

.link https://golang.org/ref/spec#Method_sets

.code slide/methodSets.txt

- 4つ目がポイント「Tのポインタ型のメソッドセットはレシーバの型が * *TまたはTであるすべてのメソッド* です」
- Talkerの例では `&Greeter{"wozozo"}` の型である `Greeter` のポインタ のメソッドセットは、 `*Greeter` だけでなく `Greeter` をレシーバにとるメソッドを含めて良い
- よって

.code -numbers src/main.go /^func \(g Greeter\)/

- `*Greeter` のメソッドセットに含めて良い

* まとめると

- `&Greeter{"wozozo"}` の型である `*Greeter` は、メソッドセットに func(g Greeter) Talk() を持つことから `Talker` インタフェースのメソッドセットを全て持つ。
- よって、`&Greeter{"wozozo"}` は `Talker` インタフェースを実装しており、`Talker` 型(の変数)に代入可能である。

- 長くなりましたが、言語仕様上問題ない代入とのこと

* では問題です

以下はどうでしょうか？

.code -numbers src/main2.go /^type Talker/,

選択問題
.code slide/main2question.txt

* 答え

- 「2. コンパイルエラー」 が正解です。[[https://play.golang.org/p/iLVSnnkTxwP][Go Playground]]
- なぜか？
- 先ほど見たメソッドセットの説明に書いてあります。

.link https://golang.org/ref/spec#Method_sets

.code slide/methodSets.txt /The method set of any other type T/

- *T型は*T型またはT型をレシーバに持つメソッドをメソッドセットとしていましたが、T型はT型をレシーバに持つメソッドだけをメソッドセットとします
- `Greeter` 型はレシーバが `*Greeter` 型のメソッドをメソッドセットに含められないということ。
- なにやら非対称ですね。なぜでしょうか。

* 具象型とポインタ型でメソッドセットが非対称な理由

- GolangのWikiにその理由らしき記述を見つけました
- [[https://github.com/golang/go/wiki/MethodSets#interfaces][Method Set golang/go wiki]]

.code slide/notAddressable.txt

- T型の値をインタフェース型の変数に代入すると、その値はアドレス化できない(not addressable)ため、レシーバに*T型を含むメソッドをメソッドセットに含められない(メソッドが呼び出せない）ということのようです。
- Wikiにあるサンプルコードを見ると理解できると思います。[[https://play.golang.org/p/seSNPNNbPqh][Go Playground]]にも貼り付けました。

* さらに問題

.code -numbers src/main3.go /^type Greeter/,/(4)/

選択問題
.code slide/main3question.txt

* 答え

- 「2. (2)と(3)はコンパイルエラー」 が正解です。[[https://play.golang.org/p/c3ePsIq3sho][Go Playground]]

.link https://golang.org/ref/spec#Assignability

.code slide/assignability.txt /x's type is identical to T./

- *T型は*T型に加えT型をレシーバに持つメソッドをメソッドセットとしますが、メソッドセットはインタフェースを実装しているかどうかの判断に使います
- よって、具象型への代入についてはメソッドセットの話は関係ありません。
- 具象型やポインタ型への変数への代入は単純に同じ型でないと代入できません。
- インタフェース型のポインタへの代入も同様に、インタフェース型のポインタ型でないと代入できません。

* 代入まとめ

- 具象型やポインタ型への代入は、同じ型でないと代入できない。
- インタフェース型への代入はちょっと特殊。
- T型がインタフェース型の時、T型のメソッドセットを持つ型の値を代入可能。
- T型はT型をレシーバに持つメソッドのみをメソッドセットとする
- *T型は*T型に加えT型をレシーバに持つメソッドをメソッドセットとする
- T型のメソッドセットに*T型をレシーバに持つメソッドを含めないのは、T型をインタフェースに代入した時に、その値が格納されているアドレスを取得できないため。(メソッドが呼び出せない）

- 今回の例 +αをまとめた。[[https://play.golang.org/p/7Ms3TsV8lkb][Go Playground]]


* 参考情報

- [[https://golang.org/ref/spec][The Go Programming Language Specification]] インタフェース以外の型への代入についてもっと知りたい人
- [[https://github.com/golang/go/wiki/MethodSets#interfaces][Method Set golang/go wiki]]
- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Methods, Interfaces and Embedded Types in Go]] 今回触れなかったEmbedded Typesについても書かれています。
- [[https://github.com/LambdaNote/errata-gosyspro-1-1/issues/29][Goならわかるシステムプログラミング 19ページの正誤情報]]
